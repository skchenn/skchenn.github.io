<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MLOVEU</title>
  
  <subtitle>文字记录人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.mloveu.com/"/>
  <updated>2020-03-22T09:31:54.660Z</updated>
  <id>https://blog.mloveu.com/</id>
  
  <author>
    <name>shikai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GC原理（二）经典垃圾收集器、垃圾回收策略</title>
    <link href="https://blog.mloveu.com/2020/03/22/JVM/gc2/"/>
    <id>https://blog.mloveu.com/2020/03/22/JVM/gc2/</id>
    <published>2020-03-22T08:56:59.000Z</published>
    <updated>2020-03-22T09:31:54.660Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇总结了GC的收集算法原理，接下来接着总结几种垃圾收集器和GC回收策略。<br>基于《深入理解Java虚拟机 第三版》第三章总结</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>经典垃圾收集器</li><li>垃圾回收策略<a id="more"></a></li><li>理解GC日志</li><li>垃圾收集器参数总结</li><li>java中的内存泄漏问题</li><li>引用和finalize()</li></ul><hr><h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><ul><li>Serial收集器</li><li>ParNew收集器</li><li>Parallel Scavenge收集器</li><li>Serial Old收集器</li><li>Parallel Old收集器</li><li>CMS收集器</li><li>Garbage First收集器</li></ul><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul><li>最基础、历史最悠久的收集器,曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择</li><li>单线程 ：只会使用一个处理器或一条收集线程去完成垃圾收集工作。</li><li>STW：进行垃圾收集时， 必须暂停其他所有工作线程， 直到它收集结束。</li><li>优点：简单而高效（与其他收集器的单线程相比） ，适用于运行在客户端模式下的虚拟机（线程停顿时间在100毫秒内且不频繁gc）</li></ul><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul><li><p>Serial收集器的多线程并行版本</p></li><li><p>JDK 7之前的遗留系统中首选的新生代收集器，因为除了Serial收集器外，目前只有它能与CMS收集器配合工作</p></li><li><p>除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致</p></li><li><p>单核处理器的环境中比Serial收集器差</p></li><li><p>多核处理器的环境中默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多的环境中，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。</p></li></ul><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ul><li><p>新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器</p></li><li><p>特点是它的关注点与其他收集器不同：目标是达到一个可控制的吞吐量（Throughput）</p><ul><li>例子：虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li><li>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</li></ul></li><li><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p></li></ul><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><ul><li><p>Serial收集器的老年代版本， 它同样是一个单线程收集器， 使用标记-整理算法</p></li><li><p>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</p></li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><ul><li>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现</li><li>在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</li></ul><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul><li><p>CMS（Concurrent Mark Sweep）收集器是一种基于标记-清除算法实现，以获取最短回收停顿时间为目标的收集器。</p></li><li><p>适用场景：较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验的应用，如运行在互联网网站或者基于浏览器的B/S系统的服务端上的Java应用</p></li><li><p>优点：并发收集、 低停顿</p></li><li><p>缺点：</p><ul><li>1、会占用一部分线程资源，导致应用程序变慢， 降低总吞吐量</li><li>2、无法处理“浮动垃圾”，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生</li><li>3、基于“标记-清除”算法实现，收集结束时会有大量空间碎片产生。</li></ul></li><li><p>主要步骤：</p><ul><li>初始标记 仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；</li><li>并发标记 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；</li><li>重新标记 为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（详见3.4.6节中关于增量更新的讲解），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；</li><li>并发清除 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li></ul></li></ul><h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><ul><li><p>主要面向服务端应用的垃圾收集器</p></li><li><p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC） ，要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。</p></li><li><p>而G1收集器可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p></li><li><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p></li><li><p>G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p></li><li><p>可以由用户指定期望的停顿时间。</p></li><li><p>G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p></li></ul><hr><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul><li>对象优先在Eden分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li><li>动态对象年龄判定</li><li>空间分配担保</li></ul><hr><h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><ul><li>见ppt</li></ul><h2 id="java中的内存泄漏问题"><a href="#java中的内存泄漏问题" class="headerlink" title="java中的内存泄漏问题"></a>java中的内存泄漏问题</h2><ul><li>见ppt</li></ul><h2 id="引用和finalize"><a href="#引用和finalize" class="headerlink" title="引用和finalize()"></a>引用和finalize()</h2><ul><li>见ppt</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇总结了GC的收集算法原理，接下来接着总结几种垃圾收集器和GC回收策略。&lt;br&gt;基于《深入理解Java虚拟机 第三版》第三章总结&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;经典垃圾收集器&lt;/li&gt;
&lt;li&gt;垃圾回收策略
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="GC" scheme="https://blog.mloveu.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>GC原理（一）概述及垃圾收集算法</title>
    <link href="https://blog.mloveu.com/2020/03/22/JVM/note-20200322/"/>
    <id>https://blog.mloveu.com/2020/03/22/JVM/note-20200322/</id>
    <published>2020-03-22T06:56:19.000Z</published>
    <updated>2020-03-22T09:35:03.394Z</updated>
    
    <content type="html"><![CDATA[<p>这周要准备的培训PPT是关于GC原理的，趁周末有时间，我把自己整理的GC原理等知识总结一下，方便以后复习。</p><h2 id="GC原理-主要考察点"><a href="#GC原理-主要考察点" class="headerlink" title="GC原理-主要考察点"></a>GC原理-主要考察点</h2><ul><li>Java层堆结构</li><li>经典GC策略</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>垃圾回收概述</li><li>两种判断对象存活的方法</li><li>垃圾收集算法<a id="more"></a></li></ul><hr><h3 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h3><h4 id="何为GC"><a href="#何为GC" class="headerlink" title="何为GC"></a>何为GC</h4><ul><li>Java虚拟机一种自动内存管理机制，可以对内存堆中已经死亡或长久无法使用的对象进行清除和回收</li><li>能有效利用内存和防止内存泄漏</li><li>将内存管理这种容易出错的行为交给计算机去管理，有利于防止人为的错误，解放开发人员。</li></ul><h4 id="为何要了解GC原理"><a href="#为何要了解GC原理" class="headerlink" title="为何要了解GC原理"></a>为何要了解GC原理</h4><ul><li>遇到内存泄漏、溢出、系统性能受GC影响较大等问题时，可以快速定位并解决问题。</li><li>有利于养成注意使用内存的良好编程习惯</li></ul><h4 id="Java虚拟机内存模型"><a href="#Java虚拟机内存模型" class="headerlink" title="Java虚拟机内存模型"></a>Java虚拟机内存模型</h4><ul><li><p><strong>程序计数器</strong></p><ul><li>存放指令地址</li></ul></li><li><p><strong>Java虚拟机栈</strong></p><ul><li>存放基本数据类型、堆中对象的引用，服务于jvm执行的Java方法</li></ul></li><li><p><strong>本地方法栈</strong></p><ul><li>同上，区别在于服务于jvm执行的native方法</li></ul></li><li><p><strong>Java堆</strong></p><ul><li>存放对象实例</li></ul></li><li><p><strong>方法区</strong></p><ul><li>存放类信息、常量、静态变量、即时编译器编译后的代码等</li></ul></li></ul><h4 id="程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。"><a href="#程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。" class="headerlink" title="程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。"></a>程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。</h4><h4 id="哪些线程需要回收"><a href="#哪些线程需要回收" class="headerlink" title="哪些线程需要回收"></a>哪些线程需要回收</h4><ul><li>Java堆–对象实例，GC频率高</li><li>方法区– 废弃的常量和不再使用的类型，由于回收条件苛刻，GC频率低</li></ul><h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><ul><li>新生代的Eden区内存写满</li><li>老年代或者永久代的内存写满</li></ul><h4 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h4><ul><li>分代回收，对应不同区域有不同的回收策略</li><li>判断对象存活状态，回收已死对象</li></ul><hr><h3 id="两种判断对象存活的方法"><a href="#两种判断对象存活的方法" class="headerlink" title="两种判断对象存活的方法"></a>两种判断对象存活的方法</h3><ul><li>引用计数法</li><li>可达性分析算法</li></ul><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><ul><li><p>原理：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p></li><li><p>缺陷：看似简单的算法有很多例外情况要考虑， 必须要配合大量额外处理才能保证正确地工作，难以解决<strong>对象之间相互循环引用</strong>的问题，因此主流的Java虚拟机都没有选用引用计数算法来管理内存</p></li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>原理： 通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</li><li>GC Roots： 虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、Java虚拟机内部的引用、所有被同步锁（synchronized关键字）持有的对象……</li><li>关于引用：当一个对象通过Object obj = new Object()创建时，new语句会在Java堆里面创建一个Object对象，而Java虚拟机栈会生成一个变量obj,这个obj的值是Object对象的地址，obj指向Object对象这个关系被称为引用。引用又分强引用、软引用、弱引用、虚引用。new一个对象是强引用。</li></ul><hr><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="主要从如何判断对象的消亡出发"><a href="#主要从如何判断对象的消亡出发" class="headerlink" title="主要从如何判断对象的消亡出发"></a>主要从如何判断对象的消亡出发</h4><ul><li>引用计数法——主要Java虚拟机未涉及</li><li>追踪式垃圾收集<ul><li>分代收集理论</li><li>标记-清除</li><li>标记-复制</li><li>标记-整理</li></ul></li></ul><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><h5 id="为何分代"><a href="#为何分代" class="headerlink" title="为何分代"></a>为何分代</h5><ul><li>不同的对象的生命周期是不一样的</li><li>为了提高回收效率，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在</li></ul><h5 id="Java1-8以前虚拟机中共划分为三个代：年轻代-Young-Generation-、年老点-Old-Generation-和持久代-Permanent-Generation-。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。"><a href="#Java1-8以前虚拟机中共划分为三个代：年轻代-Young-Generation-、年老点-Old-Generation-和持久代-Permanent-Generation-。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。" class="headerlink" title="Java1.8以前虚拟机中共划分为三个代：年轻代(Young Generation)、年老点(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。"></a>Java1.8以前虚拟机中共划分为三个代：年轻代(Young Generation)、年老点(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</h5><h5 id="分代收集方法"><a href="#分代收集方法" class="headerlink" title="分代收集方法"></a>分代收集方法</h5><ul><li>整堆收集（ Full GC） ： 收集整个Java堆和方法区的垃圾收集</li><li>部分收集（ Partial GC）：目标不是完整收集整个Java堆的垃圾收集<ul><li>新生代收集（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。</li><li>老年代收集（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。 另外请注意“Major GC”这个说法现在有点混淆， 在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。</li></ul></li></ul><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><ul><li>最基础的收集算法 ，后续的收集算法大多都是以标记-清除算法为基础， 对其缺点进行改进而得到的</li><li>算法分为“标记”和“清除”两个阶段：<ul><li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li><li>标记过程就是对象是否属于垃圾的判定过程</li></ul></li><li>缺点：<ul><li>1、第一个是执行效率不稳定， 如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>2、第二个是内存空间的碎片化问题， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul><h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5><ul><li><p>简称为复制算法。 为了解决标记-清除算法面对大量可回收对象时执行效率低的问题</p></li><li><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</p></li><li><p>优点：</p><ul><li>对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可</li></ul></li><li><p>缺点：</p><ul><li>如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销</li><li>这种复制回收算法的代价是将可用内存缩小为了原来的一半， 空间浪费较多</li></ul></li><li><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代 </p></li></ul><h5 id="标记-复制算法优化-Appel式回收"><a href="#标记-复制算法优化-Appel式回收" class="headerlink" title="标记-复制算法优化-Appel式回收"></a>标记-复制算法优化-Appel式回收</h5><ul><li>HotSpot虚拟机的Serial、 ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局</li><li>把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。<br>发生垃圾搜集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间。</li><li>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间， 即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代） 进行分配担保（Handle Promotion） 。</li></ul><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><ul><li>老年代算法</li><li>标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存</li><li>好处：解决标记-清除算法导致的弥散于堆中的存活对象导致的空间碎片化问题</li><li>弊端：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”</li></ul><hr><h4 id="垃圾收集算法总结"><a href="#垃圾收集算法总结" class="headerlink" title="垃圾收集算法总结"></a>垃圾收集算法总结</h4><ul><li>标记-清除算法：后两种算法的基础<ul><li>执行效率不稳定（面对大量可回收对象）</li><li>内存空间碎片化</li></ul></li><li>标记-复制算法：用于新生代<ul><li>面对大量可回收对象执行效率高</li><li>内存浪费较多</li></ul></li><li>标记-整理算法：用于老年代<ul><li>解决了空间碎片化的问题</li><li>整理操作需要暂停进程（STW）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周要准备的培训PPT是关于GC原理的，趁周末有时间，我把自己整理的GC原理等知识总结一下，方便以后复习。&lt;/p&gt;
&lt;h2 id=&quot;GC原理-主要考察点&quot;&gt;&lt;a href=&quot;#GC原理-主要考察点&quot; class=&quot;headerlink&quot; title=&quot;GC原理-主要考察点&quot;&gt;&lt;/a&gt;GC原理-主要考察点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java层堆结构&lt;/li&gt;
&lt;li&gt;经典GC策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;垃圾回收概述&lt;/li&gt;
&lt;li&gt;两种判断对象存活的方法&lt;/li&gt;
&lt;li&gt;垃圾收集算法
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="GC" scheme="https://blog.mloveu.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>为新的一周打气</title>
    <link href="https://blog.mloveu.com/2020/03/16/%E9%9A%8F%E7%AC%94/essay-2020-3-16/"/>
    <id>https://blog.mloveu.com/2020/03/16/%E9%9A%8F%E7%AC%94/essay-2020-3-16/</id>
    <published>2020-03-15T16:04:12.000Z</published>
    <updated>2020-03-22T09:59:46.176Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="47194ed2fa5b50003cf0900caddb75fe8d6c2ceeefbeb5a44526df7a5aec53a4">754a1ff7fc351f8c35cefa054a64a8e833512ed7b5f5e37acb09a14abceded9566622a581a8338f83bb6a36da350b424b70da88eb38d28bdba0376e819b9c968d4617094d41807c971d4d1921d52830397abce567fde0267539282a961fabec6bd0be15385064de03ff59d9f948ba374b186e725b1a7fb103220db63852eabfdbfd6a76898a32cdaaad68142b00c11a58594b408957f1fdfa7dcf256504b3f123b4f0a5a72e536f85f7fabf08abbfcaebb4a2d03f2f859908b00f16833091409344eb291b0af98fcd1f8d00afbdf9b67d791f6ddc484fa273b7c08984bc66f748d1b20fd9bf286e99ec1c4c8dd0059ee5451114aac9d32b064d5445b24b155aa434b0c553c27c592271947d2c81443b566d9a2b714ec8dd52f0cd9d6590c70dd4fd2221a09bdde4dc108b1da2822ee3efac963ff2df8e7f1aafe7d3be8638a56980b84ecd9a8a3a1e95d417c60c1f6663dd2d69fe73210d40bd9050ffa419c36f644ddb25b9d59a424832af5e73cd92428705297a37ff5eaa6df418aff46b08b4069732f21e0da6dc1134e55eaf2e29012eb337ea4896d1759f2b795fca55e8886bd8e2633c386c07e48c421a441780c4570c7cd3912dfd694589c1762232a6f31f0d093c518abc5db313aaccadf197952d00410d022199eaed356f4b25ced55647204b7bb6785b81a1323d8f9ce19bbc33e1a72caed4e81eddd2a1f36655446cc0309fa895a1e060c2a0edea90ccea5ce6c739874e991f2838ceb7a920a43e3916043821b40a26e07b965d6d21ba3d21972292ca04d22970d61fc77a0844b7cf4bf036de931140f967de6d81d789798a5395e9098530475cfccbadf8bff7715970f1dbaedea750f8e3f92c013e9d0796f509ab799342795739297afe72326ab7fe5c0b892f377e200f64af70f4757981cce00abc9072b70f2a644c79fcd4405c90307df97d7b614db84d7a5a3d5ba7b543331a5a69c223eaf890d2446d215b4b6814786a87eed266be0d51c29e4aeeb19a3b01cb683ed6dc0b6348b663d120c6b2ad02fba74de1c9842f159a5b51b0410f8f606df86bc8b9195fdd0a8f7c80b82788379a15b990ab12e49c2029b302e4c0ac88ae485563ee89cf1f005c4975313ef2d5a7ad8c6867374fa290fb28b5481265a0c7a1f223f0e5dd89ada52281417595866e6c53da486f6dc0188a605791a27db54256a432d11880d65252fbdac81e5985f7de49cdaf9a38297b314c7c8018de7308bec6bd1d932f889309408d29e201b1f63a9ac34c89b38d1cbc1cb6edc058d989a060897b4aec5ae76fa69d6792ea4db3f7b4ae0d42a574ad9a9c8f5d9c25addf02aeff47b99a8cf0c73a7fcc447f76b6604ed298d3dd6108e0b5349775619073bb6cc71d839cc767354f81b69cc0ec37c58eff876e34844e0ba523cee0f730e9fbfa9913305310369335fa4fed4b2e083d1d04a848a0bb5561bfb5e75567507050ea4891bc73e025c895f7d04b9d681d7a77e2f56ef915df872004a310b9b5b09c0af75a5f09a05f5151837651e2fa1b83dc24f4e9f7321fa9dcc9ee28724002c84a359af22c744e052d55351da056919988210831abd47a8711958a4f7075257c59aa81df2d794d7f7450203351ba9491fc1ccf762336cdc352662f6ab9948e4ced0b83abfc10217e33b9b4cb49c6d60b311cc3e2fd89eca560060e1908dba9ffe04a2a8b75a9e2fc41bed8a805a083f5208c83efed5b9f3890c394ccd6b980915e17fc9034d3f04c70e415f0b7256d1c5dd37e2af12c0cc99ff05c23d1e1731d742ffe10f92db7c7712c1d579b16b085245cc7164abba00876f2601d5c3bff8bcc14c7d342441cb6bbdb3e8b128f8cf2b067c57efbff56d2c20629583ef8c8a64ab4ceac20fa422cb59db00f587d265d3f3ec2ae3dd95aed0daf1fd7b9af2ea4cfe330c57489d74837f53af70c2952c15b0444c3b7102103ede10a2c7ec20524bced8ff867b4f28cd6072b7015a2ab4b1e82846964efafc180de7893640dd2b84e1c094a128bd9123f4ad692c284490e58b1684c7bc55dc0c8311bcbcae6d8c543b5b6fa45b7a55982b381c79bd67d798ba00092d98b6d98acd74bd211fa51c4ef5bdfea7a380f8d7f3c22029a7819db5ad4388596d1c093cfee932dc2a8f9004f3c28d73583b1857645e7a08dc60c52eac9e01101c8c93279e6426bff21aba7d35b1c0835cd06ea9620c9b57dd8440c60769f5785da25dd23b44faa18bfa5cdbce7eb977207aae4251ae81e318b45b3ee28eba6d8b73074fe9162b487f761219e47f4647ac1c67741387499200749f5a63e0930db4f552522ca4864d9e2d9529de03fc27906571a41d4a3ee65779ce7fabf2f7623a10cbfd997dca1d629d335341a3e4b8bd1534d791e12f35576523462f2a410bc902fe09a8fa9aed48c02da5a89ed174fdf2b7437e5d643468c7b78597dc07170f4e736dfaf92e7b36fab202fca7d8a0763d1dc9ddd46b11762c44d6d5d21a65a9ef28358bb6be87e639a753d71a1e62f155937e3244ed8309256e289bd067439fe07a6dae3b07d7a43f1fabec386fe81b81714fb84a228b61e09b2a8977c63cc6a38d947adf4aebb3836da220ae411af8109ca156c6fa7b360286f2f1b3f761f3cad65dc93e1ee43b20ad466214379bd0a59955e502e06b3706bcacc933d2eb5356439f73fa48f4fa7bf53dfdb498a438bcad54f6449a44a13dbc5dd7ba40747e12c0fcd5a1754bd3184bff26c66a68faddc09b9d7c2f9cda97241c185f3864533df7c8572fa00f0ecba5ad14baf9cd06ce0d132a228b125f409aca997143a63ff07c3752ac725143f80e4df4cb6c317df5e0d53aa9080ac702cd5d50f80ca0b6869c3efa5677fd09f1f6084c68c96c33ec9b566643</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="essay" scheme="https://blog.mloveu.com/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo - 如何给博客分类、打标签</title>
    <link href="https://blog.mloveu.com/2020/03/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-category/"/>
    <id>https://blog.mloveu.com/2020/03/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo-category/</id>
    <published>2020-03-15T10:04:37.000Z</published>
    <updated>2020-03-22T08:59:50.146Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 添加分类和标签</p><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>在scaffolds目录下的post.md添加分类categories</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: note</span><br></pre></td></tr></table></figure></li><li><p>在每个博客的开头加上 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories: </span><br><span class="line">- note</span><br></pre></td></tr></table></figure></li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><ul><li><p>在每个博客的开头加上 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line">- java</span><br><span class="line">- 知识</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 添加分类和标签&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="hexo" scheme="https://blog.mloveu.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo - 初次搭建博客记录</title>
    <link href="https://blog.mloveu.com/2020/03/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/blog/"/>
    <id>https://blog.mloveu.com/2020/03/15/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/blog/</id>
    <published>2020-03-15T03:58:58.000Z</published>
    <updated>2020-03-22T08:59:30.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ul><li><p>安装node.js、git、hexo</p></li><li><p>远程部署到GitHub pages</p><a id="more"></a></li></ul><h2 id="hexo官方安装教程"><a href="#hexo官方安装教程" class="headerlink" title="hexo官方安装教程"></a>hexo官方安装教程</h2><ul><li><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo</a></li></ul><hr><h2 id="个人搭建详细过程"><a href="#个人搭建详细过程" class="headerlink" title="个人搭建详细过程"></a>个人搭建详细过程</h2><h3 id="安装node-js和git"><a href="#安装node-js和git" class="headerlink" title="安装node.js和git"></a>安装node.js和git</h3><ul><li><p>windows用户从 <a href="https://npm.taobao.org/mirrors/node/v12.16.1/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node/v12.16.1/</a> 下载对应windows的msi包，直接安装即可</p></li><li><p>由于我的电脑上以前就装了git，所以不需要安装，具体安装过程就木有了（可以参考hexo的git安装教程）。</p></li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ul><li><p>cmd进入需要安装hexo的目录，依次执行下面命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init hexo</span><br><span class="line"></span><br><span class="line">cd hexo</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>浏览器打开localhost:4000即可看到‘hello word’默认博客模板</p></li><li><p>注意：由于npm服务器在国外，国内有可能会连不上，安装时报</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rollbackFailedOptional: verb npm-session ******************</span><br></pre></td></tr></table></figure></li><li><p>解决方法一：镜像服务器设置直接cmd输入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>解决方法二：找到nodejs下的.npmrc或者去c盘user下找.npmrc直接编辑配置文件。在配置文件修改以下两项：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy&#x3D;null</span><br><span class="line">registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>如果npm install的过程中卡住了，可以cirl+C结束安装，然后把“C:\Users\666\AppData\Roaming”下的npm和npm-cache两个目录删掉，重新执行命令安装</p></li></ul><hr><h3 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h3><p>本地生成了博客之后只能在自己本地浏览，如果需要部署在网络上，需要使用GitHub Pages或者服务器，由于hexo生成的是静态博客，没有后台管理系统，所以推荐使用GitHub Pages进行远程部署。</p><ul><li><p>新建个人git仓库，命名格式为 用户名.github.io</p></li><li><p>安装hexo-deployer-git</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改 博客目录下的配置文件_config.yml中的deploy字段</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git仓库项目地址</span><br><span class="line">branch: 分支</span><br><span class="line">    message: 自定义提交说明，这个字段可以没有</span><br></pre></td></tr></table></figure></li><li><p>生成博客并部署</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate &#x2F;&#x2F; hexo g</span><br><span class="line"></span><br><span class="line">hexo deploy &#x2F;&#x2F; hexo d</span><br></pre></td></tr></table></figure></li><li><p>打开 用户名.github.io ，即可看到部署上去的博客</p></li></ul>]]></content>
    
    <summary type="html">
    
      记录了我人生中第一次尝试搭建博客的过程以及遇到的坑，这也是自己博客之路的起航之篇。
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="hexo" scheme="https://blog.mloveu.com/tags/hexo/"/>
    
      <category term="博客搭建" scheme="https://blog.mloveu.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
