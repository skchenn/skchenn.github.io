<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MLOVEU</title>
  
  <subtitle>文字记录人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.mloveu.com/"/>
  <updated>2020-03-22T08:40:51.060Z</updated>
  <id>https://blog.mloveu.com/</id>
  
  <author>
    <name>shikai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GC原理（一）概述及垃圾收集算法</title>
    <link href="https://blog.mloveu.com/2020/03/22/note-20200322/"/>
    <id>https://blog.mloveu.com/2020/03/22/note-20200322/</id>
    <published>2020-03-22T06:56:19.000Z</published>
    <updated>2020-03-22T08:40:51.060Z</updated>
    
    <content type="html"><![CDATA[<p>这周要准备的培训PPT是关于GC原理的，趁周末有时间，我把自己整理的GC原理等知识总结一下，方便以后复习。</p><h2 id="GC原理-主要考察点"><a href="#GC原理-主要考察点" class="headerlink" title="GC原理-主要考察点"></a>GC原理-主要考察点</h2><ul><li>Java层堆结构</li><li>经典GC策略</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>垃圾回收概述</li><li>两种判断对象存活的方法</li><li>垃圾收集算法</li><li>经典垃圾收集器</li><li>理解GC日志</li><li>垃圾收集器参数总结</li><li>垃圾回收策略</li><li>java中的内存泄漏问题</li><li>引用和finalize()</li></ul><hr><h3 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h3><h4 id="何为GC"><a href="#何为GC" class="headerlink" title="何为GC"></a>何为GC</h4><ul><li>Java虚拟机一种自动内存管理机制，可以对内存堆中已经死亡或长久无法使用的对象进行清除和回收</li><li>能有效利用内存和防止内存泄漏</li><li>将内存管理这种容易出错的行为交给计算机去管理，有利于防止人为的错误，解放开发人员。</li></ul><h4 id="为何要了解GC原理"><a href="#为何要了解GC原理" class="headerlink" title="为何要了解GC原理"></a>为何要了解GC原理</h4><ul><li>遇到内存泄漏、溢出、系统性能受GC影响较大等问题时，可以快速定位并解决问题。</li><li>有利于养成注意使用内存的良好编程习惯</li></ul><h4 id="Java虚拟机内存模型"><a href="#Java虚拟机内存模型" class="headerlink" title="Java虚拟机内存模型"></a>Java虚拟机内存模型</h4><ul><li><p><strong>程序计数器</strong></p><ul><li>存放指令地址</li></ul></li><li><p><strong>Java虚拟机栈</strong></p><ul><li>存放基本数据类型、堆中对象的引用，服务于jvm执行的Java方法</li></ul></li><li><p><strong>本地方法栈</strong></p><ul><li>同上，区别在于服务于jvm执行的native方法</li></ul></li><li><p><strong>Java堆</strong></p><ul><li>存放对象实例</li></ul></li><li><p><strong>方法区</strong></p><ul><li>存放类信息、常量、静态变量、即时编译器编译后的代码等</li></ul></li></ul><h4 id="程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。"><a href="#程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。" class="headerlink" title="程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。"></a>程序计数器、虚拟机栈和本地方法栈都是线程私有的，内存自动产生和回收。Java堆和方法区是线程共享的，内存分配和回收都是动态的，是GC主要关注的地方。</h4><h4 id="哪些线程需要回收"><a href="#哪些线程需要回收" class="headerlink" title="哪些线程需要回收"></a>哪些线程需要回收</h4><ul><li>Java堆–对象实例，GC频率高</li><li>方法区– 废弃的常量和不再使用的类型，由于回收条件苛刻，GC频率低</li></ul><h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><ul><li>新生代的Eden区内存写满</li><li>老年代或者永久代的内存写满</li></ul><h4 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h4><ul><li>分代回收，对应不同区域有不同的回收策略</li><li>判断对象存活状态，回收已死对象</li></ul><hr><h3 id="两种判断对象存活的方法"><a href="#两种判断对象存活的方法" class="headerlink" title="两种判断对象存活的方法"></a>两种判断对象存活的方法</h3><ul><li>引用计数法</li><li>可达性分析算法</li></ul><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><ul><li><p>原理：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p></li><li><p>缺陷：看似简单的算法有很多例外情况要考虑， 必须要配合大量额外处理才能保证正确地工作，难以解决<strong>对象之间相互循环引用</strong>的问题，因此主流的Java虚拟机都没有选用引用计数算法来管理内存</p></li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>原理： 通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</li><li>GC Roots： 虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、Java虚拟机内部的引用、所有被同步锁（synchronized关键字）持有的对象……</li><li>关于引用：当一个对象通过Object obj = new Object()创建时，new语句会在Java堆里面创建一个Object对象，而Java虚拟机栈会生成一个变量obj,这个obj的值是Object对象的地址，obj指向Object对象这个关系被称为引用。引用又分强引用、软引用、弱引用、虚引用。new一个对象是强引用。</li></ul><hr><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="主要从如何判断对象的消亡出发"><a href="#主要从如何判断对象的消亡出发" class="headerlink" title="主要从如何判断对象的消亡出发"></a>主要从如何判断对象的消亡出发</h4><ul><li>引用计数法——主要Java虚拟机未涉及</li><li>追踪式垃圾收集<ul><li>分代收集理论</li><li>标记-清除</li><li>标记-复制</li><li>标记-整理</li></ul></li></ul><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><h5 id="为何分代"><a href="#为何分代" class="headerlink" title="为何分代"></a>为何分代</h5><ul><li>不同的对象的生命周期是不一样的</li><li>为了提高回收效率，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在</li></ul><h5 id="Java1-8以前虚拟机中共划分为三个代：年轻代-Young-Generation-、年老点-Old-Generation-和持久代-Permanent-Generation-。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。"><a href="#Java1-8以前虚拟机中共划分为三个代：年轻代-Young-Generation-、年老点-Old-Generation-和持久代-Permanent-Generation-。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。" class="headerlink" title="Java1.8以前虚拟机中共划分为三个代：年轻代(Young Generation)、年老点(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。"></a>Java1.8以前虚拟机中共划分为三个代：年轻代(Young Generation)、年老点(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</h5><h5 id="分代收集方法"><a href="#分代收集方法" class="headerlink" title="分代收集方法"></a>分代收集方法</h5><ul><li>整堆收集（ Full GC） ： 收集整个Java堆和方法区的垃圾收集</li><li>部分收集（ Partial GC）：目标不是完整收集整个Java堆的垃圾收集<ul><li>新生代收集（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。</li><li>老年代收集（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。 目前只有CMS收集器会有单独收集老年代的行为。 另外请注意“Major GC”这个说法现在有点混淆， 在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。 目前只有G1收集器会有这种行为。</li></ul></li></ul><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><ul><li>最基础的收集算法 ，后续的收集算法大多都是以标记-清除算法为基础， 对其缺点进行改进而得到的</li><li>算法分为“标记”和“清除”两个阶段：<ul><li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li><li>标记过程就是对象是否属于垃圾的判定过程</li></ul></li><li>缺点：<ul><li>1、第一个是执行效率不稳定， 如果Java堆中包含大量对象， 而且其中大部分是需要被回收的， 这时必须进行大量标记和清除的动作， 导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li><li>2、第二个是内存空间的碎片化问题， 标记、 清除之后会产生大量不连续的内存碎片， 空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul><h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5><ul><li><p>简称为复制算法。 为了解决标记-清除算法面对大量可回收对象时执行效率低的问题</p></li><li><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉</p></li><li><p>优点：</p><ul><li>对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可</li></ul></li><li><p>缺点：</p><ul><li>如果内存中多数对象都是存活的， 这种算法将会产生大量的内存间复制的开销</li><li>这种复制回收算法的代价是将可用内存缩小为了原来的一半， 空间浪费较多</li></ul></li><li><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代 </p></li></ul><h5 id="标记-复制算法优化-Appel式回收"><a href="#标记-复制算法优化-Appel式回收" class="headerlink" title="标记-复制算法优化-Appel式回收"></a>标记-复制算法优化-Appel式回收</h5><ul><li>HotSpot虚拟机的Serial、 ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局</li><li>把新生代分为一块较大的Eden空间和两块较小的Survivor空间， 每次分配内存只使用Eden和其中一块Survivor。<br>发生垃圾搜集时， 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上， 然后直接清理掉Eden和已用过的那块Survivor空间。</li><li>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间， 即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代） 进行分配担保（Handle Promotion） 。</li></ul><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><ul><li>老年代算法</li><li>标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存</li><li>好处：解决标记-清除算法导致的弥散于堆中的存活对象导致的空间碎片化问题</li><li>弊端：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”</li></ul><hr><h4 id="垃圾收集算法总结"><a href="#垃圾收集算法总结" class="headerlink" title="垃圾收集算法总结"></a>垃圾收集算法总结</h4><ul><li>标记-清除算法：后两种算法的基础<ul><li>执行效率不稳定（面对大量可回收对象）</li><li>内存空间碎片化</li></ul></li><li>标记-复制算法：用于新生代<ul><li>面对大量可回收对象执行效率高</li><li>内存浪费较多</li></ul></li><li>标记-整理算法：用于老年代<ul><li>解决了空间碎片化的问题</li><li>整理操作需要暂停进程（STW）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周要准备的培训PPT是关于GC原理的，趁周末有时间，我把自己整理的GC原理等知识总结一下，方便以后复习。&lt;/p&gt;
&lt;h2 id=&quot;GC原理-主要考察点&quot;&gt;&lt;a href=&quot;#GC原理-主要考察点&quot; class=&quot;headerlink&quot; title=&quot;GC原理-主要考察点&quot;
      
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="GC" scheme="https://blog.mloveu.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>为新的一周打气</title>
    <link href="https://blog.mloveu.com/2020/03/16/essay-2020-3-16/"/>
    <id>https://blog.mloveu.com/2020/03/16/essay-2020-3-16/</id>
    <published>2020-03-15T16:04:12.000Z</published>
    <updated>2020-03-15T16:47:52.967Z</updated>
    
    <content type="html"><![CDATA[<p>现在是2020年3月16号0点，是新的一周的开始。<br>想起这一周我需要面对的工作任务，心里很焦虑，感觉今晚要很难入睡了。</p><a id="more"></a><p>周末两天，我其实应该为下一周的工作（考试、课程培训）做准备的，但是我一直以来难以摆脱的拖延症让我这一周没有做任何的准备工作，心里不断地降低自己的完成标准：</p><p>  考试一定要过–&gt;这次不过也没关系，反正很难，下次再过吧<br>  培训的ppt提前两周准备–&gt;前一周周末准备–&gt;培训前几天准备</p><p>就这样，我的两件重要的工作还没准备就即将到来，此刻心情真的很后悔。但是似乎又习惯了，正如此刻我在写日记而不去抓紧时间准备。</p><p>感觉，自从毕业以来这一两年，我都没有真正一心一意去完成某件事情，很多都是拖到最后草草了事。或许我的工作事业没什么进展也是由于自己不够努力。</p><p>周末两天可以说没有意义，也可以说极具纪念价值。因为我这两天萌发了搭建个人博客的意头，并且付诸行动。虽然在选主题、选域名浪费不少时间，但是看到自己的博客搭起来还是有较大的成就感的。</p><p>千里之行，始于足下，决定写博客就一定要坚持下去，说实话，我觉得我把这两天搭博客的那股劲用在工作、学习上，日积月累应该能有很大成就，起码会比现在要好很多。</p><p>不多想了，总之过去的教训一定要吸取，未来的事情也一定要做好。</p><h2 id="未来的方向：以博客驱动学习，努力提高技术，提高归纳、表达能力。"><a href="#未来的方向：以博客驱动学习，努力提高技术，提高归纳、表达能力。" class="headerlink" title="未来的方向：以博客驱动学习，努力提高技术，提高归纳、表达能力。"></a>未来的方向：以博客驱动学习，努力提高技术，提高归纳、表达能力。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在是2020年3月16号0点，是新的一周的开始。&lt;br&gt;想起这一周我需要面对的工作任务，心里很焦虑，感觉今晚要很难入睡了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="essay" scheme="https://blog.mloveu.com/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo - 如何给博客分类、打标签</title>
    <link href="https://blog.mloveu.com/2020/03/15/hexo-category/"/>
    <id>https://blog.mloveu.com/2020/03/15/hexo-category/</id>
    <published>2020-03-15T10:04:37.000Z</published>
    <updated>2020-03-22T06:57:13.944Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 添加分类和标签</p><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>在scaffolds目录下的post.md添加分类categories</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories: note</span><br></pre></td></tr></table></figure></li><li><p>在每个博客的开头加上 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories: </span><br><span class="line">- note</span><br></pre></td></tr></table></figure></li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li><ul><li><p>在每个博客的开头加上 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line">- java</span><br><span class="line">- 知识</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 添加分类和标签&lt;/p&gt;
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="hexo" scheme="https://blog.mloveu.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo - 初次搭建博客记录</title>
    <link href="https://blog.mloveu.com/2020/03/15/blog/"/>
    <id>https://blog.mloveu.com/2020/03/15/blog/</id>
    <published>2020-03-15T03:58:58.000Z</published>
    <updated>2020-03-15T14:57:21.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ul><li><p>安装node.js、git、hexo</p></li><li><p>远程部署到GitHub pages</p><a id="more"></a></li></ul><h2 id="hexo官方安装教程"><a href="#hexo官方安装教程" class="headerlink" title="hexo官方安装教程"></a>hexo官方安装教程</h2><ul><li><a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo</a></li></ul><hr><h2 id="个人搭建详细过程"><a href="#个人搭建详细过程" class="headerlink" title="个人搭建详细过程"></a>个人搭建详细过程</h2><h3 id="安装node-js和git"><a href="#安装node-js和git" class="headerlink" title="安装node.js和git"></a>安装node.js和git</h3><ul><li><p>windows用户从 <a href="https://npm.taobao.org/mirrors/node/v12.16.1/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node/v12.16.1/</a> 下载对应windows的msi包，直接安装即可</p></li><li><p>由于我的电脑上以前就装了git，所以不需要安装，具体安装过程就木有了（可以参考hexo的git安装教程）。</p></li></ul><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ul><li><p>cmd进入需要安装hexo的目录，依次执行下面命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">hexo init hexo</span><br><span class="line"></span><br><span class="line">cd hexo</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>浏览器打开localhost:4000即可看到‘hello word’默认博客模板</p></li><li><p>注意：由于npm服务器在国外，国内有可能会连不上，安装时报</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rollbackFailedOptional: verb npm-session ******************</span><br></pre></td></tr></table></figure></li><li><p>解决方法一：镜像服务器设置直接cmd输入</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>解决方法二：找到nodejs下的.npmrc或者去c盘user下找.npmrc直接编辑配置文件。在配置文件修改以下两项：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy&#x3D;null</span><br><span class="line">registry&#x3D;http:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>如果npm install的过程中卡住了，可以cirl+C结束安装，然后把“C:\Users\666\AppData\Roaming”下的npm和npm-cache两个目录删掉，重新执行命令安装</p></li></ul><hr><h3 id="远程部署"><a href="#远程部署" class="headerlink" title="远程部署"></a>远程部署</h3><p>本地生成了博客之后只能在自己本地浏览，如果需要部署在网络上，需要使用GitHub Pages或者服务器，由于hexo生成的是静态博客，没有后台管理系统，所以推荐使用GitHub Pages进行远程部署。</p><ul><li><p>新建个人git仓库，命名格式为 用户名.github.io</p></li><li><p>安装hexo-deployer-git</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改 博客目录下的配置文件_config.yml中的deploy字段</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: git仓库项目地址</span><br><span class="line">branch: 分支</span><br><span class="line">    message: 自定义提交说明，这个字段可以没有</span><br></pre></td></tr></table></figure></li><li><p>生成博客并部署</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate &#x2F;&#x2F; hexo g</span><br><span class="line"></span><br><span class="line">hexo deploy &#x2F;&#x2F; hexo d</span><br></pre></td></tr></table></figure></li><li><p>打开 用户名.github.io ，即可看到部署上去的博客</p></li></ul>]]></content>
    
    <summary type="html">
    
      记录了我人生中第一次尝试搭建博客的过程以及遇到的坑，这也是自己博客之路的起航之篇。
    
    </summary>
    
    
      <category term="note" scheme="https://blog.mloveu.com/categories/note/"/>
    
    
      <category term="hexo" scheme="https://blog.mloveu.com/tags/hexo/"/>
    
      <category term="博客搭建" scheme="https://blog.mloveu.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
